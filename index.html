<!DOCTYPE html>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Accessible Technology Test Adapter API</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<script src='https://www.w3.org/Tools/respec/respec-w3c-common' async="async" class='remove'></script>
<!-- <script src='respec.js' async="async" class='remove'></script> -->
<script class="remove">
var respecConfig = {
    // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
    specStatus:           "ED",
    processVersion:       "2005",
    includePermalinks:    true,
    permalinkEdge:        true,
    permalinkHide:        false,

    // the specification's short name, as in http://www.w3.org/TR/short-name/
    shortName:            "atta-api",

    // if you wish the publication date to be other than today, set this
    // publishDate:  "2015-11-30",

    // if the specification's copyright date is a range of years, specify
    // the start date here:
    copyrightStart: "2016",

    // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
    // and its maturity status
    // previousPublishDate:  "2014-08-14",
    // previousMaturity:  "WD",
    // previousDiffURI:        "http://www.w3.org/TR/2014/WD-media-accessibility-reqs-20140814/",

    // if there a publicly available Editor's Draft, this is the link
    edDraftURI: "https://spec-ops.github.io/atta-api/",

    // if this is a LCWD, uncomment and set the end of its review period
    // lcEnd: "2009-08-05",

    // editors, add as many as you like
    // only "name" is required
    editors:  [
      {
        name: "Joanmarie Diggs",
        url: 'http://www.igalia.com',
        mailto: "jdiggs@igalia.com",
        company: "Igalia, S.L.",
        companyURI: "http://www.igalia.com"
      },
                { name: "Shane McCarron", url: 'https://www.spec-ops.io',
                  mailto: "shane@spec-ops.io",
                  company: "Spec-Ops", companyURL: "https://www.spec-ops.io" }
    ],

    // name of the WG
    wg:           "Accessibility Platorm Architecture",

    // URI of the public WG page
    wgURI:        "https://www.w3.org/WAI/ARIA/",

    // name (with the @w3c.org) of the public mailing to which comments are due
    wgPublicList: "public-apa",

    // URI of the patent status for this WG, for Rec-track documents
    // !!!! IMPORTANT !!!!
    // This is important for Rec-track documents, do not copy a patent URI from a random
    // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
    // Team Contact.
    wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/32212/status",

    // Depth for the TOC
    maxTocLevel: 3,

    // include introduction sections in the ToC
    tocIntroductory: true,
    doRDFa: 1.1,
    preProcess: [ setup ]
};

function setup() {
  // add a handler to come in after all the definitions are resolved
  //
  // New logic: If the reference is within a 'dl' element of
  // class 'termlist', and if the target of that reference is
  // also within a 'dl' element of class 'termlist', then
  // consider it an internal reference and ignore it.

  require(["core/pubsubhub"], function(respecEvents) {
      "use strict";
      var termNames = [] ;
      respecEvents.sub('end', function(message) {
          if (message === 'core/link-to-dfn') {
              $.each(document.querySelectorAll("dfn"), function(i, item) {
                  var $t = $(item) ;
                  var titles = $t.getDfnTitles();
                  var n = $t.makeID("dfn", titles[0]);
                  if (n) {
                      termNames[n] = $t.parent() ;
                  }
              });
              // all definitions are linked
              $("a.internalDFN").each(function () {
                  var $item = $(this) ;
                  var t = $item.attr('href');
                  if ( $item.closest('dl.termlist').length ) {
                      if ( $(t).closest('dl.termlist').length ) {
                          // do nothing
                          return;
                      }
                  }
                  var r = t.replace(/^#/,"") ;
                  if (termNames[r]) {
                      delete termNames[r] ;
                  }
              });
      // delete any terms that were not referenced.
              Object.keys(termNames).forEach(function(term) {
                  var $p = $("#"+term) ;
                  if ($p) {
                      var tList = $p.getDfnTitles();
                      $p.parent().next().remove();
                      $p.remove() ;
                      tList.forEach(function( item ) {
                          if (respecConfig.definitionMap[item]) {
                              delete respecConfig.definitionMap[item];
                          }
                      });
                  }
              });
          }
      });
  });
};

</script>
</head>
<body>
<section id="abstract">
  <p>This document presents an architecture and attendant components that together enable
  interaction between the [[Web-Protocol-Tests]] framework, the [[testharness.js]] library that is part of that
  framework, and the Accessibility API on any platform.  It is loosely based upon work done in the ARIA Working Group
  and its ancestor Protocols and Formats Working Group, but takes its inspriation from the way that the various Accessibility
  API Mapping specifications provide for a consistent way to expose and interrogate aspects of essentially any window
  on any platform.</p>
</section>
<section id="sotd">
  <p>This is a very drafty document intended to be a place to capture the definition of the
  architecture as it is developed. In particular, the contents of <a
    href="#terminology">Terminology</a> are in a state of flux, and the content of
  the <a href="#teststatements">Testable Statements</a> is still being refined on
  a per-platform basis.</p>
</section>
<section id="introduction">
  <h2>Introduction</h2>
  <p>Historically, testing of aspects of the web platform that are
  outside of the user agent have been very challenging.  Such
  testing requires specialized test rigs, platform unique
  instrumentation, etc.  Often the use of such tooling is helpful,
  but still does not enable fully automated testing of those aspects
  in a way that is portable or scales well.  In these situations,
  manual testing has been required. Previous testing of the ARIA
  Specification(s) and related <a>accessibility api mappings</a>
  fell into this category.</p>
  <p>This specification defines a mechanism whereby any platform
  that supports Web Platform Accessibility and exposes that support
  through a platform <a>Accessibility API</a> can be tested
  automatically.  In addition, it defines a simplified declarative
  grammar that can be used to define the tests themselves &emdash;
  thereby simplifying the overall task of writing the tests in the
  first place.
  </p>

  <p>This document starts out describing the way testing at the W3C
  operates for most of the web platform, then illustrates the way in
  which it is extended through the facilities defined herein.  After
  that it provides specifications for each of the components of the
  system and their interactions with one another.  Finally, it
  discusses some ways in which the system could be extended in the
  future to further ease test development and make the testing more
  thorough.</p>
</section>
<section>
  <h2>Theory of Operation</h2>
  <p>In <a>WPT</a> a <dfn>parent window</dfn> controls
  the selection of tests, and then opens a
  <dfn data-lt='test window'>child window</dfn> to execute the
  selected tests.  That child window uses a Javascript library to control test
  sequencing, reporting, management if windows, etc.  For most tests, that model looks
  something like this:</p>
  <img style="width: 95%; align: center" src="wpt-dialog.svg" alt="Simple WPT Dialog Example">
  <p>Through this document and the tools that it defines,
  ARIA testing extends this model by connecting the child window to an
  <a>ATTA</a> <abbr title="Accessible Technology Test Adapter">ATTA</abbr> through another
  Javascript library and a well defined protocol and set of messages. The
  diagram below shows this expansion.</p>
  <img style="width: 95%; align: center" src="dialog.svg" alt="WPT Dialog with ATTA">
</section>
<section id="teststatements">
  <h2>Testable Statements</h2>
  <p>A testable statement is a simple assertion about the behavior of a system
  that, when examined, should evaluate to true.  In the case of ARIA
  specifications, the testable statements are maintained in various wikis.
  They include this assertion, and also include
  supporting information to inform the test system which aspects of the underlying
  systems need to be examined to evaluate the assertion.</p>
  <p class="note">It is possible that in some environments an ATTA will
  not be be available. Consequently, additional properties of the
  Testable Statement can help a manual tester understand how to
  perform a similar test without ATTA assistance.  Examples include
  the <code>URL</code> and <code>description</code> properties
  mentioned below.</p>
  <p>Consider the following example:</p>
  <pre class="example">
== Testable Statements for ARIA 1.1 features ==

SpecURL:  https://www.w3.org/TR/wai-aria11

=== gridcell ===

==== Description ====

When an element has a role with a value of 'grid', its aria-rowcount
and aria-colcount attributes descibe the dimensions of the grid
represented by that element and its contents.

Reference: #some_id

&lt;pre&gt;
If given
  &lt;div role='grid' id='test' aria-rowcount='3' aria-colcount='2'&gt;
   &lt;div role='row'&gt;
      &lt;span role='gridcell'&gt;
        &lt;button&gt;hello&lt;/button&gt;
     &lt;/span&gt;
   &lt;/div&gt;
  &lt;/div&gt;
then role: grid, celcount: 2, rowcount: 3
&lt;/pre&gt;
  </pre>
  <p>This example presents a description of the test's purpose, a
  reference to the section of the specification that defines the
  behavior under test, and an HTML fragment and conditions that should be met.
  Beyond this, the testable statement needs to show how these conditions are
  evaluated through each defined <a>API mapping</a>. An example of one such would be:</p>
  <pre class="example">
  |-
  |rowspan=4|ATK
  |property
  |role
  |is
  |ROLE_TABLE
  |-
  |property
  |objectAttributes
  |contains
  |xml-roles:grid
  |-
  |property
  |interfaces
  |contains
  |Table
  |-
  |property
  |interface
  |contains
  |Selection
  </pre>

  <p>This is an example of a MediaWiki-style table fragment.  In this case it is a
  series of rows and columns that describe the various items that the ATK ATTA
  will evaluate.  The WPT ARIA test generator tool parse tables like this and
  generates an HTML file containing a JSON representation of the data structured
  in such a way that it can be processed by the <a>ATTA Communication Module</a>.
  The JSON for the examples above looks like:</p>

  <pre class="example">
    { "title": 'grid',
      "reference": 'https://www.w3.org/TR/wai-aria11#some_id',
      "description": "When an element has a role with a value of 'grid', its aria-rowcount and aria-colcount attributes descibe the dimensions of the grid represented by that element and its contents.",
      "steps": [
      {
        "type":  "test",
        "title": "step 1",
        "element": "test",
          "test" : {
             "ATK" : [
                [

                   "property"
                   "role",
                   "is",
                   "ROLE_TABLE"
                ],
                [
                   "property"
                   "objectAttributes",
                   "contains",
                   "xml-roles:grid"
                ],
                [
                   "property"
                   "objectAttributes",
                   "contains",
                   "rowcount:3",
                ],
                [
                   "property"
                   "objectAttributes",
                   "contains",
                   "colcount:2",
                ],
                [
                   "property"
                   "interfaces",
                   "contains",
                   "Table"
                ],
                [
                   "property",
                   "interface",
                   "contains",
                   "Selection"
                ]
             ],
             ....
          }
        }
      ]
    }
  </pre>

  <p>The system will automatically generate [[WPT]] compatible test
  cases that are formatted as defined in this specification.  Test
  cases can also be written by hand.  Examples and a template are
  available in the <code>wai-aria/tools</code> directory of the WPT
  github repository.</p>

  <p class="note">
  The architecture of this system allows for multiple "steps" per
  test (see <a>Test Steps</a>).  The current syntax structure for
  Testable Statements does not allow for the expression of
  multiple "steps". It is possible that this will be added in the
  future.</p>

  <p class="note">
  In the future, it is possible that that the detailed per-platform
  API assertions will be automatically created from a basic
  assertion by applying the rules from the <a>Accessibility API Mapping</a>
  document associated with each specification.   See <a>Future
      Plans</a> for more information.
  </p>
  <section id="S_assertions">
    <h3>Assertions</h3>
    <p>Each <a>platform accessibility API</a> has unique facilities.  The per-platform
    API assertion <i>structure</i> is identical, but the contents are necessarily different.  The
    general structure is:</p>

    <dl>
      <dt>Test Class</dt>
      <dd>The class of thing being tested.  Examples include a <i>relation</i>, <i>property</i>, <i>result</i> (of
      a method call), or <i>event</i>.  As a special case, a Test Class of <code>TBD</code> is a
      placeholder that means
      the assertions are "to be determined".  An ATTA that sees a
      Test Class of <code>TBD</code> SHOULD respond with a result of "FAIL" and a message that includes
      sufficient detail about the accessibility tree associated with the <code>element</code> in
      question that a test developer could review that information and use it to develop the correct
      assertions for a given platform.</dd>
      <dt>Test Type</dt>
      <dd>The <i>type</i> within the <i>Test Class</i>.  Examples include <i>role</i>, <i>name</i>,
      <i>subrole</i>, etc.</dd>
      <dt>Assertion Type</dt>
      <dd>A <i>verb</i> that indicates how the assertion should be evaluated.  These include
      <code>exists</code>,
      <code>is</code>,
      <code>isNot</code>,
      <code>contains</code>,
      <code>doesNotContain</code>,
      <code>isLT</code>,
      <code>isLTE</code>,
      <code>isGT</code>,
      <code>isGTE</code>,
      <code>isType</code>, and
      <code>isAny</code>.</dd>
      <dt>Value</dt>
      <dd>A value (or value list) against which to evaluate using ASSERTION TYPE. If there are
      multiple values, they are enclosed in brackets and separated with commas and optional whitespace (e.g., [value1, value2,
      value3]).  When an Assertion Type of <i>exists</i> is used, legal values are <i>true</i> and <i>false</i>.
      <p class='note'>At this time commas embedded in values within a value list are NOT supported.</p></dd>

    </dl>

    <p class="note" title="Event Tests">The TEST CLASS of event is special in that the each occurrence of the TEST TYPE type establishes a
    context for the next event rows in the table. Each subsequent event row is an assertion about an event of the type referenced in that
    first special row. That context continues until the end of the table, until a row that is NOT an event assertion, or until a row that is
    an event but with a TEST TYPE of type.</p>

    <p>The remainder of this section defines the specific contents.</p>

    <section id="S_assertions_ATK">
      <h4>ATK Assertion Contents</h4>
    </section>
    <section id="S_assertions_AXAPI">
      <h4>AXAPI Assertion Contents</h4>
    </section>
    <section id="S_assertions_IA2">
      <h4>IAccessible2 Assertion Contents</h4>
    </section>
    <section id="S_assertions_MSAA">
      <h4>MSAA Assertion Contents</h4>
    </section>
    <section id="S_assertions_UIA">
      <h4>UIA Assertion Contents</h4>
    </section>
  </section>
</section>
<section id="S_test_steps">
  <h2><dfn>Test Steps</dfn></h2>
  <p>A test case is a series of test steps.  Each step has a type,
  the default for which is "assertions".  This section defines each
  of the types and how those should be expressed in a test case
  file.</p>
  <section>
    <h3>assertions</h3>
    <p>A <dfn>Simple Test</dfn> is a test in which the ATTA only needs to interrogate
    the state of various Accessible Technology roles, states, properties, methods, or
    events on the platform.  Each platform has its own collection of these
    that are documented in the various <a>Accessibility API Mapping</a>
    specifications and the specification of the platform
    <a>Accessibility API</a>.</p>
    <pre class="hilite">
    {
      "type":  "test",
      "title": "busy true",
      "element": "test",
      "test" : {
         "ATK" : [
            [
               "property",
               "interfaces",
               "doesNotContain",
               "Selection"
            ],
            [
               "property",
               "states",
               "contains",
               "STATE_BUSY"
            ]
         ]
      }
    }
    </pre>
  </section>
  <section>
    <h3>event</h3>
    <p>An "event" entry is a declarative way to fire an event at a
    specific element.</p>
    <pre>
    {
      "type": "event",
      "element": "test",
      "event": "focus",
      "description": "Fire a focus event at ID attribute value of 'test'"
    }
    </pre>
  </section>
  <section>
    <h3>script</h3>
    <p>A "script" step includes javascript code that will be
    executed in the context of the test child window.</p>
    <pre>
    {
      "type": "script",
      "title": "change busy",
      "script": "{ var el = document.getElementById('test'); \
                   if (el) { el.setAttribute('aria-busy', true); } }"
    }
    </pre>
  </section>
</section>
<section>
    <h2><dfn data-lt="atta communication module">ATTAcomm.js - ATTA communication library</dfn></h2>
  <p>ATTAcomm.js is a Javascript library that works in conjunction with the WPT
  testrunner.js to setup and teardown tests, communicate with the ATTA, perform
  local actions within a test window, and report the results of the testing to WPT.
  The library has a constructor that returns the object and also performs the
  testing if there is an ATTA available.</p>
  <pre class="idl">
    interface ATTAcomm {
      attribute testDefinition theTest;
    } ;

    dictionary testDefinition {
      required DOMString title;
      required sequence&lt;testStep&gt; steps;
    };

    dictionary testStep {
      DOMString type = "test";
      required DOMString title;
      required DOMString element;
      FrozenArray&lt;APImap&gt; test;
    };

    dictionary APImap {
      required APIList APIName;
      required FrozenArray&lt;Assertion&gt; tests;
    };

    dictionary Assertion {
      required assertionType type;
      required assertionName name;
      assertionValue value;
    };

    enum APIList { "MSAA", "ATK", "IAccessible2", "UIA", "AXAPI" } ;
  </pre>
</section>
<section>
  <h2>Accessible Technology Test Adapter</h2>
  <section>
    <h3>Protocol</h3>
    <p>The ATTA protocol is a simple command/response protocol relying upon
    HTTP.  By default, an ATTA SHOULD listen on port 4119 (A11Y).  It is NOT
    RESTful.  Instead, it uses JSON messages and wraps them in a simple
    request where the path portion indicates that command. A typical
    conversation between the ATTA and the Framework might look like this:</p>
  <img style="width: 95%; align: center" src="atta-flow.svg" alt="Communication between Test, Library, and ATTA">
  </section>
  <section>
    <h3>Message Structure</h3>
    <p>Queries and responses are all in JSON.</p>
  </section>
  <section>
    <h3>Commands</h3>
    <section>
      <h4>start</h4>
      <p>The start message is designed to ensure that the ATTA is
      ready, that it can find the window under test, and also to
      help ATTAcomm understand which API and API version is
      supported.</p>
      <dl>
        <dt>test</dt>
        <dd>The name of the overall test case</dd>
        <dt>url</dt>
        <dd>The url the test case was loaded from</dd>
      </dl>

      <p>The reply for this message takes the form:</p>
      <dl>
        <dt>status</dt>
        <dd>In indication of whether the ATTA could find the window in
        which the test will take place given the test name and url.  Values are
        <code>READY</code> or <code>ERROR</code></dd>
        <dt>statusText</dt>
        <dd>A message about any error</dd>
        <dt>ATTAname</dt>
        <dd>The name of the ATTA</dd>
        <dt>ATTAversion</dt>
        <dd>A version string about the ATTA</dd>
        <dt>API</dt>
        <dd>The name of the <a>Accessibility API</a> supported by ATTA</dd>
        <dt>APIversion</dt>
        <dd>A version string about the Accessibility API</dd>
        <dt>log</dt>
        <dd>optional, ATTA-specific information about the
        accessibility tree associated with the window being
        evaluated.  This SHOULD be preformatted information that
        can be embedded by the <a>ATTA Communication Module</a>
        in the test page to assist a test developer in developing or
        debugging a test.</dd>
      </dl>
      <pre class="example" title="Example start request">
      {
        "test":  "name of the overall test case",
        "url":   "url from which the content is loaded"
      }
      </pre>
      <pre class="example" title="Example start response">
      {
        "status":      "READY",
        "statusText":  "",
        "ATTAname":    "WPT Sample ATTA",
        "ATTAversion": 1,
        "API":         myAPI,
        "APIversion":  myAPIversion,
        "log":         "formatted logging information"
      }
      </pre>
    </section>
    <section>
      <h4>input</h4>
      <p>The input message is optional.  If it is sent, it defines an input activity that the ATTA needs to perform on behalf of the test in order to stimulate some action
      required for the next step(s) of the test.</p>
      <dl>
        <dt>element</dt>
        <dd>The id of the element at which the activities are targeted</dd>
        <dt>activities</dt>
        <dd>A list of activity objects that are to be performed in sequence:
        <dl>
          <dt>activity</dt>
          <dd>An activity name (e.g., keypress, keydown, keyup, click, mousedown, mouseup)</dd>
          <dt>key</dt>
          <dd>The name of the key (for key activities).  Abstract key names are defined in <a href="https://www.w3.org/TR/uievents-key/">UIEVENTS-KEY</a>.</dd>
        </dl>
      </dl>

      <p>The reply for this message takes the form:</p>
      <dl>
        <dt>status</dt>
        <dd>In indication of whether the ATTA could perform the activities requested.
        Values are <code>READY</code> or <code>ERROR</code></dd>
        <dt>statusText</dt>
        <dd>A message about any error</dd>
        <dt>log</dt>
        <dd>optional, ATTA-specific information about the
        activities performed.
        This SHOULD be preformatted information that
        can be embedded by the <a>ATTA Communication Module</a>
        in the test page to assist a test developer in developing or
        debugging a test.</dd>
      </dl>
      <pre class="example" title="Example input request">
      {
        "element":  "test",
        "activities": [
          { "activity": "keypress",
            "key":      "ArrowDown"
          },
          { "activity": "click" }
        ]
      }
      </pre>
      <pre class="example" title="Example input response">
      {
        "status":      "READY",
        "statusText":  "",
        "log":         "formatted logging information"
      }
      </pre>
    </section>
    <section>
      <h4>listen</h4>
      <p>The listen message is optional.  If it is sent, it means one or more subtests are going to have assertions that need to be
      evaluated against events, and the ATTA is expected to listen for those events.</p>
      <dl>
        <dt>events</dt>
        <dd>A list of event names the ATTA should capture for the duration of this test.</dd>
      </dl>

      <p>The reply for this message takes the form:</p>
      <dl>
        <dt>status</dt>
        <dd>In indication of whether the ATTA could set up listeners for
        the requested events.
        Values are <code>READY</code> or <code>ERROR</code></dd>
        <dt>statusText</dt>
        <dd>A message about any error</dd>
        <dt>log</dt>
        <dd>optional, ATTA-specific information about the
        events being listened for.
        This SHOULD be preformatted information that
        can be embedded by the <a>ATTA Communication Module</a>
        in the test page to assist a test developer in developing or
        debugging a test.</dd>
      </dl>
      <pre class="example" title="Example listen request">
      {
        "events":  [ "focused", "expanded", "selected" ]
      }
      </pre>
      <pre class="example" title="Example listen response">
      {
        "status":      "READY",
        "statusText":  "",
        "log":         "formatted logging information"
      }
      </pre>
    </section>
    <section>
      <h4>test</h4>
      <p>The test message contains one or more assertions that the
      ATTA is to evaluate against the <a>Accessibility API</a>.  For
      each assertion in the request, the ATTA is to return
      information on the result of checking the assertion.</p>
      <dl>
        <dt>name</dt>
        <dd>The name of the test</dd>
        <dt>element</dt>
        <dd>The 'id' of an element that will be examined by the
        ATTA</dd>
        <dt>data</dt>
        <dd>A JSON structure containing the a11y data to check. Note that this is an array where each member maps to a nested array of information from a 'row' in the testable statement. The exact structure and values of the information varies by Accessibility API, but in general have a structure like:
        <dl>
          <dt>class</dt>
          <dd>The class of assertion to evaluate (e.g., state, property, relation, result)</dd>
          <dt>type</dt>
          <dd>The type of item in the class</dd>
          <dt>assertion</dt>
          <dd>What we are asserting about this class+type</dd>
          <dt>values</dt>
          <dd>The value or values to evaluate with the
          assertion.</dd>
        </dl>
        </dd>
      </dl>

      <p>Note that in order to make the comparison of test
      results across platforms "apples to apples" similar, the
      'rows' in the testable statement will be evaluated and
      their results collected into a single result for the
      overall 'test statement'. Any failure or other messages
      will be included in the result for that overall 'test
      statement'.</p>

      <p>The reply for this message takes the form:</p>
      <dl>
        <dt>status</dt>
        <dd>In indication of whether the ATTA could evaluate the
        assertions or not.  Values are <code>OK</code> and
        <code>ERROR</code></dd>
        <dt>statusText</dt>
        <dd>A message about any error</dd>
        <dt>log</dt>
        <dd>optional, ATTA-specific information about the
        acceswsibility tree associated with the element being
        evaluated.  This SHOULD be preformatted information that
        can be embedded by the <a>ATTA Communication Module</a>
        in the test page to assist a test developer in developing or
        debugging a test.</dd>
        <dt>results</dt>
        <dd>A list of result objects corresponding to each
        array member in <code>data</code> above. The result
        objects have the following members:
        <dl>
          <dt>result</dt>
          <dd>one of PASS or FAIL</dd>
          <dt>message</dt>
          <dd>information that explains a failure (if any). This information is attached to the failure information along with the assertion
          that was being evaluated so a tester can help to correct the problem.</dd>
          <dt>log</dt>
          <dd>optional ATTA-specific information showing
          information about the acessibility tree that was
          examined when evaluating the assertion. When there is log data returned
          it is augmented with the information about the assertion being
          examined.  Used when debugging or developing tests.</dd>
        </dl>
        </dd>
      </dl>
      <pre class="example" title="Example test request">
      {
        "name":      "subtest name",
        "element":   "id of element to check",
        "data":      [ [ "thingClass", "thingType", "thingAssertion", "thingValue" ],
                       [ "thingClass", "thingType", "thingAssertion", "thingValue" ]
                     ]
      }
      </pre>
      <pre class="example" title="Example test response">
      {
        "status":      "OK",
        "statusText":  "",
        "log":         "",
        "results":     [
                         { "result":  "PASS",
                           "log":     "Logging information about test run"
                         },
                         { "result":  "FAIL",
                           "message": "Some diagnostic about the failure",
                           "log":     "detailed logging"
                         }
                       ]
      }
      </pre>
    </section>
    <section>
      <h4>end</h4>
      <p>The end message just indicates the current test case is
      complete.  It has no payload and expects nothing in the
      response. The <a>ATTA</a> SHOULD do a complete cleanup of
      anything in its environment before it replies to the
      message.</p>
    </section>
  </section>
</section>
<section id="terminology" class="appendix informative">
  <h2>Terminology</h2>
  <dl class="termlist">
    <dt><dfn><abbr title="Accessible Technology Test Adapter">ATTA</abbr></dfn>
    <dd>The ATTA is a tool that acts as the interface between the <a>WPT</a>
    <a>child window</a> and the <a>platform accessibility API</a>.  It
    interprets requirements defined in <a>testable statements</a> and
    evaluates them against the characteristics of the <a>child window</a> to
    help evaluate the conformance of the <a>platform accessibility API</a> to
    the requirements in related W3C Recommendations.</dd>
    <dt><dfn><abbr title="Web Platform Tests">WPT</abbr></dfn></dt>
    <dd>The collection of tests and tools that the W3C relies upon to exercise
    the Web Platform (where that is the collection of technologies that
    comprise the World Wide Web).</dd>
    <dt><dfn data-lt="testable statement|testable statements">Testable
      Statement</dfn></dt>
    <dd>A simple (hopefully atomic) definition about the behavior of some
    component. In the context of this system, a testable statement includes
    information about what behaviors should or should not be attached to an
    element with a unique ID within the <a>child window</a>.</dd>
    <dt><dfn data-lt="platform accessibility api|accessibility api|accessibility apis">Accessibility <abbr title="Application Programming Interface">API</abbr></dfn></dt>
    <dd>
    <p>Operating systems and other platforms provide a set of interfaces that expose information about <a class="termref" data-lt="object">objects</a> and <a class="termref" data-lt="event">events</a> to <a>assistive technologies</a>. Assistive technologies use these interfaces to get information about and interact with those <a class="termref" data-lt="widget">widgets</a>. Examples of accessibility APIs are <a href="https://msdn.microsoft.com/en-us/library/ms697270(VS.85).aspx">Microsoft Active Accessibility</a> [[MSAA]], <a href="https://msdn.microsoft.com/en-us/library/ee684013%28VS.85%29.aspx">Microsoft User Interface Automation</a> [[UI-AUTOMATION]], <abbr title="Microsoft Active Accessibility">MSAA</abbr> with <cite><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd561898(v=vs.85).aspx"><abbr title="User Interface Automation">UIA</abbr> Express</a></cite> [[UIA-EXPRESS]], the
    <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Protocols/NSAccessibility_Protocol/index.html">Mac <abbr title="OS Ten">OS X</abbr> Accessibility Protocol</a> [[AXAPI]], the <cite><a href="https://developer.gnome.org/atk/unstable/">Linux/Unix Accessibility Toolkit</a></cite> [[ATK]] and <cite><a href="https://developer.gnome.org/libatspi/stable/">Assistive Technology Service Provider Interface</a></cite> [[AT-SPI]], and <a href="http://www.linuxfoundation.org/collaborate/workgroups/accessibility/iaccessible2">IAccessible2</a> [[IAccessible2]].</p>
    </dd>
    <dt><dfn data-lt="api mappings|api mapping|accessibility api mappings">Accessibility <abbr>API</abbr> Mapping</dfn></dt>
    <dd>A specification that defines the relationship between ARIA
    roles, properties, states, and events to their corresponding
    aspects of a specific platform's implementation.</dd>
    <dt><dfn>Accessibility Subtree</dfn></dt>
    <dd>
    <p>An <a>accessible object</a> in the <a>accessibility tree</a> and its descendants in that tree. It does not include objects which have relationships other than parent-child in that tree. For example, it does not include objects linked via <pref>aria-flowto</pref> unless those objects are also descendants in the <a>accessibility tree</a>.</p>
    </dd>
    <dt><dfn>Accessibility Tree</dfn></dt>
    <dd>
    <p>Tree of <a class="termref" data-lt="accessible object">accessible objects</a> that represents the structure of the user interface (UI). Each node in the accessibility tree represents an element in the <abbr title="user interface">UI</abbr> as exposed through the <a>accessibility <abbr title="Application Programming Interface">API</abbr></a>; for example, a push button, a check box, or container.</p>
    </dd>
    <dt><dfn>Accessible Description</dfn></dt>
    <dd>
    <p>An accessible description provides additional information, related to an interface element, that complements the <a>accessible name</a>. The accessible description might or might not be visually perceivable. </p>
    </dd>
    <dt><dfn data-lt="accessible names">Accessible Name</dfn></dt>
    <dd>
    <p>The accessible name is the name of a user interface element. Each platform <a>accessibility <abbr title="application programming interface">API</abbr></a> provides the accessible name property. The value of the accessible name may be derived from a visible (e.g., the visible text on a button) or invisible (e.g., the text alternative that describes an icon) property of the user interface element.  See related <a>accessible description</a>.</p>
    <p>A simple use for the accessible name property may be illustrated by an &quot;OK&quot; button. The text &quot;OK&quot; is the accessible name. When the button receives focus, assistive technologies may concatenate the platform's role description with the accessible name. For example, a screen reader may speak &quot;push-button OK&quot; or &quot;OK button&quot;. The order of concatenation and specifics of the role description (e.g., &quot;button&quot;, &quot;push-button&quot;, &quot;clickable button&quot;) are determined by platform <a class="termref" data-lt="accessibility api">accessibility API</a>s or <a>assistive technologies</a>.</p>
    </dd>
    <dt><dfn data-lt="accessible objects">Accessible object</dfn></dt>
    <dd>
    <p>A <a>node</a> in the <a>accessibility tree</a> of a platform <a>accessibility <abbr title="application programming interface">API</abbr></a>. Accessible objects expose various <a class="termref" data-lt="state">states</a>, <a class="termref" data-lt="property">properties</a>, and <a class="termref" data-lt="event">events</a> for use by <a>assistive technologies</a>.  In the context of markup languages (e.g., HTML and SVG) in general, and of WAI-ARIA in particular, markup <a class="termref" data-lt="element">elements</a> and their <a class="termref" data-lt="attribute">attributes</a> are represented as accessible objects.  </p>
    </dd>
    <dt><dfn>Activation behavior</dfn></dt>
    <dd>
    <p>The action taken when an <a>event</a>, typically initiated by users through an input device, causes an element to fulfill a defined role. The role may be defined for that element by the host language, or by author-defined variables, or both. The role for any given element may be a generic action, or may be unique to that element. For example, the activation behavior of an <abbr title="Hypertext Markup Language">HTML</abbr> or <abbr title="Scalable Vector Graphics">SVG</abbr> <code>&lt;a&gt;</code> element shall be to cause the user agent to traverse the link specified in the <code>href</code> attribute, with the further optional parameter of specifying the browsing context for the traversal (such as the current window or tab, a named window, or a new window); the activation behavior of an <abbr title="Hypertext Markup Language">HTML</abbr> <code>&lt;input&gt;</code> element with the <code>type</code> attribute value <code>submit</code> shall be to send the values of the form elements to an author-defined <abbr title="Internationalized Resource Identifiers">IRI</abbr> by the author-defined <abbr title="Hypertext Transfer Protocol">HTTP</abbr> method.</p>
    </dd>
    <dt><dfn data-lt="assistive technology">Assistive Technologies</dfn></dt>
    <dd><p>Hardware and/or software that:</p>
    <ul>
      <li>relies on services provided by a <a>user agent</a> to retrieve and render Web content </li>
      <li>works with a user agent or web content itself through the use of APIs, and</li>
      <li>provides services beyond those offered by the user agent to facilitate user interaction with web content by people with disabilities</li>
    </ul>
    <p>This definition may differ from that used in other documents.</p>
    <p>Examples of assistive technologies that are important in the context
    of this document include the following:</p>
    <ul>
      <li>screen magnifiers, which are used to enlarge and improve the visual readability of rendered text and images;</li>
      <li>screen readers, which are most-often used to convey information through synthesized speech or a refreshable Braille display;</li>
      <li>text-to-speech software, which is used to convert text into synthetic speech;</li>
      <li>speech recognition software, which is used to allow spoken control and dictation;</li>
      <li>alternate input technologies (including head pointers, on-screen keyboards, single switches, and sip/puff devices), which are used to simulate the keyboard;</li>
      <li>alternate pointing devices, which are used to simulate mouse pointing and clicking.</li>
    </ul>
    </dd>
    <dt><dfn data-lt="attributes">Attribute</dfn></dt>
    <dd>
    <p>In this specification, attribute is used as it is in markup languages. Attributes are structural features added to <a class="termref" href="#dfn-element">elements</a> to provide information about the <a class="termref" href="#dfn-state">states</a> and <a class="termref" href="#dfn-property">properties</a> of the <a class="termref" href="#dfn-object">object</a> represented by the element.</p>
    </dd>
    <dt><dfn data-lt="classes">Class</dfn></dt>
    <dd>
    <p>A set of instance <a class="termref" href="#dfn-object">objects</a> that share similar characteristics.</p>
    </dd>
    <dt><dfn data-lt="deprecate|deprecation">Deprecated</dfn></dt>
    <dd>
    <p>A deprecated <a class="termref" href="#dfn-role">role</a>, <a class="termref" href="#dfn-state">state</a>, or <a class="termref" href="#dfn-property">property</a> is one which has been outdated by newer constructs or changed circumstances, and which may be removed in future versions of the <abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr> specification. <a class="termref" data-lt="user agent">User agents</a> are encouraged to continue to support items identified as deprecated for backward compatibility. For more information, see <a href="#deprecated">Deprecated Requirements</a> in the Conformance section.</p>
    </dd>
    <dt><dfn>Desktop focus event</dfn></dt>
    <dd>
    <p>Event from/to the host operating system via the accessibility <abbr title="application programming interface">API</abbr>, notifying of a change of input focus.</p>
    </dd>
    <dt><dfn data-lt="elements|element's">Element</dfn></dt>
    <dd>
    <p>In this specification, element is used as it is in markup languages. Elements are the structural elements in markup language that contains the data profile for <a class="termref" data-lt="object">objects</a>.</p>
    </dd>
    <dt><dfn data-lt="events">Event</dfn></dt>
    <dd>
    <p>A programmatic message used to communicate discrete changes in the <a>state</a> of an <a>object</a> to other objects in a computational system. User input to a web page is commonly mediated through abstract events that describe the interaction and can provide notice of changes to the state of a document object. In some programming languages, events are more commonly known as notifications.</p>
    </dd>
    <dt><dfn>Expose</dfn></dt>
    <dd>
    <p>Translated to platform-specific <a class="termref" data-lt="accessibility api">accessibility APIs</a> as defined in the <cite><abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr> User Agent Implementation Guide.</cite> [[WAI-ARIA-IMPLEMENTATION]]</p>
    </dd>
    <dt><dfn data-lt="graphical documents">Graphical Document</dfn></dt>
    <dd>
    <p>A document containing graphic representations with user-navigable parts. Charts, maps, diagrams, blueprints, and dashboards are examples of graphical documents. A graphical document is composed using any combination of symbols, images, text, and graphic primitives (shapes such as circles, points, lines, paths, rectangles, etc).</p>
    </dd>
    <dt><dfn>Hidden</dfn></dt>
    <dd>
    <p>Indicates that the <a>element</a> is not visible, <a>perceivable</a>, or interactive to <em>any</em> user. An element is considered <em>hidden</em> if it or any one of its ancestor elements is not rendered or is explicitly hidden.</p>
    </dd>
    <dt><dfn>Informative</dfn></dt>
    <dd>
    <p>Content provided for information purposes and not required for conformance. Content required for conformance is referred to as <a>normative</a>.</p>
    </dd>
    <dt><dfn>Keyboard Accessible</dfn></dt>
    <dd>
    <p>Accessible to the user using a keyboard or <a>assistive technologies</a> that mimic keyboard input, such as a sip and puff tube. References in this document relate to <cite><a href="http://www.w3.org/TR/WCAG20/#keyboard-operation"><abbr title="Web Content Accessibility Guidelines">WCAG</abbr> 2.0 Guideline 2.1: Make all functionality available from a keyboard</a></cite> [[WCAG20]].</p>
    </dd>
    <dt><dfn data-lt="landmarks">Landmark</dfn></dt>
    <dd>
    <p>A type of region on a page to which the user may want quick access. Content in such a region is different from that of other regions on the page and relevant to a specific user purpose, such as navigating, searching, perusing the primary content, etc.</p>
    </dd>
    <dt><dfn data-lt="live regions">Live Region</dfn></dt>
    <dd>
    <p>Live regions are perceivable regions of a web page that are typically updated as a result of an external event when user focus may be elsewhere. These regions are not always updated as a result of a user interaction. This practice has become commonplace with the growing use of Ajax. Examples of live regions include a chat log, stock ticker, or a sport scoring section that updates periodically to reflect game statistics. Since these asynchronous areas are expected to update outside the user's area of focus, assistive technologies such as screen readers have either been unaware of their existence or unable to process them for the user. WAI-ARIA has provided a collection of properties that allow the author to identify these live regions and process them: aria-live, aria-relevant, aria-atomic, and aria-busy. Pre-defined live region roles are listed in the <cite><a href="http://www.w3.org/TR/wai-aria-practices/#chobet">Choosing Between Special Case Live Regions</a></cite> ([[WAI-ARIA-PRACTICES]], Section 5.3).</p>
    </dd>
    <dt><dfn>Primary Content Element</dfn></dt>
    <dd>
    <p>An implementing host language's primary content element, such as the <code>body</code> element in HTML.</p>
    </dd>
    <dt><dfn data-lt="managed states">Managed State</dfn></dt>
    <dd>
    <p><a>Accessibility API</a> <a>state</a> that is controlled by the user agent, such as focus and selection. These are contrasted with &quot;unmanaged states&quot; that are typically controlled by the author. Nevertheless, authors can override some managed states, such as aria-posinset and aria-setsize. Many managed states have corresponding CSS pseudo-classes, such as :focus, and pseudo-elements, such as ::selection, that are also updated by the user agent.</p>
    </dd>
    <dt><dfn>Nemeth Braille</dfn></dt>
    <dd>
    <p>The Nemeth Braille Code for Mathematics is a braille code for encoding mathematical and scientific notation. See <cite><a href="https://en.wikipedia.org/wiki/Nemeth_Braille">Nemeth Braille on Wikipedia</a>.</cite></p>
    </dd>
    <dt><dfn>Node</dfn></dt>
    <dd>
    <p>Basic type of <a class="termref">object</a> in the <abbr title="Document Object Model">DOM</abbr> tree or <a class="termref">accessibility tree</a>. <abbr title="Document Object Model">DOM</abbr> nodes are further specified as <a class="termref">Element</a> or <a class="termref" data-lt="Text node">Text nodes</a>, among other types. The nodes of an <a class="termref">accessibility tree</a> are <a class="termref" data-lt="accessible object">accessible objects</a>.  </p>
    </dd>
    <dt><dfn>Normative</dfn></dt>
    <dd>
    <p>Required for conformance. By contrast, content identified as <a>informative</a> or &quot;non-normative&quot; is not required for conformance.</p>
    </dd>
    <dt><dfn data-lt="objects">Object</dfn></dt>
    <dd>
    <p>In the context of user interfaces,  an item in the   perceptual user experience, represented in markup languages by one or   more <a class="termref" data-lt="element">elements</a>, and rendered by <a class="termref" data-lt="user agent">user agents</a>.</p>
    In the context of programming, the instantiation of one or more <a class="termref" data-lt="class">classes</a> and interfaces which define the general characteristics of similar objects. An object in an <a>accessibility <abbr title="Application Programming Interfaces">API</abbr></a> may represent one or more DOM objects. <a class="termref" data-lt="accessibility api">Accessibility APIs</a> have defined interfaces that are distinct from DOM interfaces.</dd>

    <dt><dfn>Ontology</dfn></dt>
    <dd>
    <p>A description of the characteristics of <a class="termref" data-lt="class">classes</a> and how they relate to each other.</p>
    </dd>
    <dt><dfn>Operable</dfn></dt>
    <dd>
    <p>Usable by users in ways they can control. References in this document relate to <cite><a href="http://www.w3.org/TR/WCAG20/#operable"><abbr title="Web Content Accessibility Guidelines">WCAG</abbr> 2.0 Principle 2: Content must be operable</a></cite> [[WCAG20]]. See <a>Keyboard Accessible</a>.</p>
    </dd>
    <dt><dfn data-lt="owned|owned element's|owned elements">Owned Element</dfn></dt>
    <dd>
    <p>An 'owned element' is any <abbr title="Document Object Model">DOM</abbr> descendant of the <a>element</a>, any element specified as a child via <pref>aria-owns</pref>, or any <abbr title="Document Object Model">DOM</abbr> descendant of the owned child.</p>
    </dd>
    <dt><dfn data-lt="owning">Owning Element</dfn></dt>
    <dd>
    <p>An 'owning element' is any <abbr title="Document Object Model">DOM</abbr> ancestor of the <a>element</a>, or any element with an <pref>aria-owns</pref> attribute which references the ID of the   element. </p>
    </dd>
    <dt><dfn>Perceivable</dfn></dt>
    <dd>
    <p>Presentable to users in ways they can sense. References in this document relate to <cite><a href="http://www.w3.org/TR/WCAG20/#perceivable"><abbr title="Web Content Accessibility Guidelines">WCAG</abbr> 2.0 Principle 1: Content must be perceivable</a></cite> [[WCAG20]].</p>
    </dd>
    <dt><dfn data-lt="properties">Property</dfn></dt>
    <dd>
    <p><a class="termref" data-lt="attribute">Attributes</a> that are essential to the nature of a given <a>object</a>, or that represent a data value associated with the object. A change of a property may significantly impact the meaning or presentation of an object. Certain properties (for example, <pref>aria-multiline</pref>) are less likely to change than <a class="termref" href="#dfn-state">states</a>, but note that the frequency of change difference is not a rule. A few properties, such as <pref>aria-activedescendant</pref>, <pref>aria-valuenow</pref>, and <pref>aria-valuetext</pref> are expected to change often. See <a href="http://www.w3.org/TR/wai-aria/states_and_properties#statevsprop">clarification of states versus properties</a>.</p>
    </dd>
    <dt><dfn data-lt="relationships">Relationship</dfn></dt>
    <dd>
    <p>A connection between two distinct things. Relationships may be of various types to indicate which <a>object</a> labels another, controls another, etc.</p>
    </dd>
    <dt><dfn data-lt="roles">Role</dfn></dt>
    <dd>
    <p>Main indicator of type. <!-- (removing, vague) The object's role is the class of <a class="termref" data-lt="object">objects</a> of which it is a member. --> This <a class="termref" data-lt="semantics">semantic</a> association allows tools to present and support interaction with the object in a manner that is consistent with user expectations about other objects of that type.</p>
    </dd>
    <dt><dfn>Root <abbr title="Accessible Rich Internet Application">WAI-ARIA</abbr> node</dfn></dt>
    <dd>
    <p> The primary element containing non-metadata content. In many languages, this is  the document element but in <abbr title="Hypertext Markup Language">HTML</abbr>, it is the <code>&lt;body&gt;</code>.</p>
    </dd>
    <dt><dfn data-lt="semantic|semantically">Semantics</dfn></dt>
    <dd>
    <p>The meaning of something as understood by a human, defined in a way that computers can process a representation of an <a>object</a>, such as <a class="termref" data-lt="element">elements</a> and <a class="termref" data-lt="attribute">attributes</a>, and reliably represent the object in a way that various humans will achieve a mutually consistent understanding of the object.</p>
    </dd>
    <dt><dfn data-lt="states">State</dfn></dt>
    <dd>
    <p>A state is a dynamic <a class="termref" href="#dfn-property">property</a> expressing characteristics of an <a>object</a> that may change in response to user action or automated processes. States do not affect the essential nature of the object, but represent data associated with the object or user interaction possibilities. See <a href="http://www.w3.org/TR/wai-aria/states_and_properties#statevsprop">clarification of states versus properties</a>.</p>
    </dd>
    <dt><dfn>Sub-document</dfn></dt>
    <dd>
    <p>Any document created from a <code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code> or similar mechanism. A sub-document may contain a document, an application or any widget such as a calendar pulled in from another server. In the <a>accessibility tree</a> there are two <a class="termref" data-lt="accessible object">accessible objects</a> for this situation&mdash;one represents the <code>&lt;frame&gt;</code>/<code>&lt;iframe&gt;</code> element in the parent document, which parents a single <a>accessible object</a> child representing the spawned document contents.</p>
    </dd>
    <dt><dfn>Target Element</dfn></dt>
    <dd>
    <p>An element specified in a <abbr title="Accessible Rich Internet Application">WAI-ARIA</abbr> relation. For example, in <code> &lt;div aria-controls=”elem1”&gt;</code>, where <code>“elem1”</code> is the ID for the target element.</p>
    </dd>
    <dt><dfn>Taxonomy</dfn></dt>
    <dd>
    <p>A hierarchical definition of how the characteristics of various <a class="termref" data-lt="class">classes</a> relate to each other, in which classes inherit the properties of superclasses in the hierarchy. A taxonomy can comprise part of the formal definition of an <a>ontology</a>.</p>
    </dd>
    <dt><dfn>Text node</dfn></dt>
    <dd>
    <p>Type of <abbr title="Document Object Model">DOM</abbr> <a class="termref" data-lt="node">node</a> that represents the textual content of an <a class="termref">attribute</a> or an <a class="termref">element</a>. A Text node has no child nodes.  </p>
    </dd>
    <dt><dfn>Understandable</dfn></dt>
    <dd>
    <p>Presentable to users in ways they can construct an appropriate meaning. References in this document relate to <cite><a href="http://www.w3.org/TR/WCAG20/#understandable"><abbr title="Web Content Accessibility Guidelines">WCAG</abbr> 2.0 Principle 3: Information and the operation of user interface must be understandable</a></cite> [[WCAG20]].</p>
    </dd>
    <dt><dfn data-lt="user agents">User Agent</dfn></dt>
    <dd>
    <p>Any software that retrieves, renders and facilitates end user interaction with Web content. This definition may differ from that used in other documents.</p>
    </dd>
    <dt><dfn>Valid IDREF</dfn></dt>
    <dd>
    <p>A reference to a target element in the same document that has a matching ID</p>
    </dd>
    <dt><dfn data-lt="widgets">Widget</dfn></dt>
    <dd>
    <p>Discrete user interface <a class="termref" href="#dfn-object">object</a> with which the user can interact. Widgets range from simple objects that have one value or operation (e.g., check boxes and menu items), to complex objects that contain many managed sub-objects (e.g., trees and grids).</p>
    </dd>
  </dl>
</section>
<section id="S_future_plans" class="appendix">
  <h2><dfn>Future Plans</dfn></h2>
  <p>This section is meant to capture plans about the evolution of
  this interface.</p>
</section>
</body>
</html>
<!-- vim: ts=2 sw=2 ai wm=10:
-->
